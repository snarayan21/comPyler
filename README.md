# Compyler 

## Names
Daniel Bessonov, Patrick Li, Saaketh Narayan

## Penkeys
bessonov, lipat, saaketh

# Algorithm
- First, the parser creates an AST over some Python source (i.e. see `parseFile` in Parser.hs).
- Then, we iterate through the AST and execute each individual statement/expression, writing to a global state (i.e. see `exec` in Compiler.hs).
  - For function definitions, we additionally pre-emptively iterate through the function body and parameters to determine the scope of each variable (i.e. see `exec` in Scope.hs).
- Once the entire AST has been iterated through, we now have a list of Python Bytecode objects (i.e. see `Instruction` in Types.hs) that we need to write to a `.pyc` file (i.e. see `makePycFile` in `Compiler.hs`).
- We similarly create a `.pyc` file for the dead-code-eliminated version of the program.

# Main components

## Parser.hs + Scope.hs + Compiler.hs
These three modules comprise the logic of the compiler and are the main components of the project. The parser module parses the input file and creates an abstract syntax tree. The scope module is responsible for figuring out the usage level of variables; for now, it supports local variables in functions and inside of loops. The compiler module uses the AST and the scope information to generate a Haskell representation of Python bytecode.

## Types.hs + Writer.hs
The types module contains the data types used to represent the Python bytecode. The writer module contains the logic for writing the bytecode to a file, as well as Writer specific data types. 

## PySyntax.hs
The PySyntax module contains the data types used to generate Python code in Haskell. For now, it only supports a subset of Python syntax; specifically, it can generate boolean and int expressions, binary and unary operators on these types, and arbitrarily nested conditional statements. We limited the scope of this module to ensure that we could generate valid Python code that is closed under these types and expressions.

## LiveVariableAnalysis.hs + GenerateCFG.hs + DeadCodeElim.hs
These three modules are responsible for performing the live variable analysis and dead code elimination. The GenerateCFG module generates a control flow graph from the generated bytecode (from the Compiler module). The LiveVariableAnalysis module performs the live variable analysis on the CFG. The DeadCodeElim module uses the results of the live variable analysis to eliminate dead code from the CFG.

# Dependencies
Compyler has the following dependencies:
```
  - binary
  - bytestring
  - language-python
  - containers
  - utf8-string
  - transformers
  - mtl
  - filepath
  - QuickCheck
  - HUnit
  - pretty
  - typed-process
  - random
  - process
```
These should be installed automatically when you run `stack ghci` in the project directory.

